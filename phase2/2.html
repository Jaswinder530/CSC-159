<small><i>
Sacramento State
<br>Computer Engineering / Computer Science
<br>CpE/CSc159 Operating System Pragmatics (Spring 2019)
<br>Instructor: W. Chang
</i></small>

<p>
<center><h3>
Phase 2 &nbsp; Process Service Calls
</h3>
</center>

<b>Process Services</tt></b>
<ol>
<li>
During the runtime, a process would call for OS services. The service
calls are coded in <b><i>sys-call.c</b></i> (prototyped by sys-call.h).
An OS fullfills these requests by running its service routine code (k-sr.c).
When this occurs the process currently running has to be supended for
the CPU to perform the service. Once a service is completed, a process
is resumed (original or an alternate from the ready-to-run queue), all
due to the outcome of the service (I/O request/wait, mutex lock, lack
of resources, etc.).

<li>
There are three services in this phase to construct: <b><i>int
GetPid(void)</i></b>, <b><i>void ShowChar(int row, int col, char
ch)</i></b>, and <i><b>void Sleep(int centi_sec)</i></b>.

<li>
Service calls are coded in <b><i>sys-call.c</i></b> with <i>inline</i>
CPU instruction assembly which invokes the kernel runtime via a software
interrupt event: <i><b>int $?</i></b>. Unlike a device interrupt such
as the timer, there is no PIC involvement. Only an entry point in the
<i>interrupt table</i> will be set to carry the address of an entry
code in <i>k-entry.S</i>, from which the kernel code and the corresponding
service routine are linked.
<li>
The service routine for <i><b>GETPID_CALL</i></b> is to put the
<i><b>run_pid</i></b> into the process trapframe (<i><b>eax</i></b>) to
be loaded by the CPU to carry back to the call function in which it is
retrieved as the function return.
<li>
The <i><b>TimerEntry</i></b> and three new entries are to be coded in
<i>k-entry.S</i>. Each entry <i>pushl</i> a unique entry ID (<i><b>entry_id</i></b>)
into the process trapframe and <i>jmp</i> to a common routine that switches
the CPU stack pointer to the kernel stack, and pushes the trapframe address
there, and finally calls Kernel(). This unique entry ID is to identify which SR
to call.
<li>
Coding details are all depicted in <i><b>CodingHints.txt</i></b>.
</ol>

<b>Enable Kernel Services</b>
<p>

<ol>
<li>
Each <i>service call</i> is an entry number in the intrrupt table where
a code address from <i><b>k-entry.S</i></b> is placed. A service does not
need to program the PIC mask or send back to it a "done" sisgnal (like the
timer srevice). However, the software overhead is having <i><b>sys-call.c</i></b>
since an <b><i>asm()</i></b> macro is needed to execute an <i><b>int $?</b></i>
call. The process thus "voluntarily" interrupt itself to let the CPU switch to
the kernel code.
<li>
Required arguments in each service calls are passed vi CPU registers via
which results from the kernel service can also be received. The CPU
instructions are coded in the asm() to perform these.
</ol>

<b>Service Routine (SR) Code</b>
<ol>
<li>
SR code are in <b><i>k-sr.c</b></i>. For the <i><b>GetPid()</i></b> call,
the entry ID (service number) is <b><i>GETPID_CALL</i></b> (48), and
<i><b>int GetPidSR(void)</i></b> would return <i><b>run_pid</i></b> to be
placed in the <i>eax</i> value of the process trapframe which will be loaded
back to the CPU as the process resumes (and be retrieved as the sys-call
function continues).
<li>
The <i><b>ShowChar()</i></b> call sends info of which <i>row</i>, which
<i>col</i>, and what character <i>ch</i> via registers <i>eax, ebx, ecx</i>
to the kernel to perform the service <i><b>ShowCharSR()</i></b>.
<li>
Given the number of <i><b>centi-seconds</i></b> to sleep, a <b><i>Sleep()</i></b>
call and SR <b><i>SleepSR()</i></b> will compute and set the wake time for
the requesting process, i.e., in its PCB, the <i><b>wake_centi_sec</i></b>
will be set by adding the current OS time (sys_centi_sec) and the requested
time. The process state will be altered to <i>SLEEP</i> and the run_pid will
queued into the sleep queue (<i>sleep_q</i>) and reset to NONE (-1).
<li>
Hence, the <i><b>TimerSR()</i></b> will need to do additional work:

<ol>
<li> upcount the system time (<i><b>sys_centi_sec</i></b>),
<li> check if wake times of processes have arrived and wake them.
</ul>
</ol>

</ul>
</ol>

<b>Deliverables</b>
<ol>
<li>
Your program should be able to perform the same functions and generate the
same runtime result as the given demo.
<li>
As before, to <i>Voyager</i> via <i>smbclient</i>, submit all source files to
be compiled (and only source files, not any other files generated by SPEDE or
the compiler). Must submit into your team folder (under folder <i>phase2</i>).
Misplacement will incur penalty. Use V2, V3, etc., only when necessary.
</ol>

<b>Review Questions</b>
<ol>
<li>
Point out the differences in setting up and servicing a device interrupt
(e.g., timer device) versus for a sys-call?
<li>
Why saving the process trapframe pointer at the beginning of Kernel()?
<li>
When checking for waking up processes? Do you use "==" or ">=?" Or other?
<li>
What can happen with <i>your</i> OS if "SleepCall(0)" or "SleepCall(-1)"
is issued in UserProc()? How can these be properly addressed/handled?
<li>
Can the OS time count ever differ from a real wall clock eventually?
<li>
What is a "cooperative" or "preemptive" OS kernel? Pros and cons?

</ol>

