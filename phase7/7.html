<body bgcolor=white>
<small><i>
Sacramento State<br>
Computer Engineering / Computer Science<br>
CpE/CSc 159 Operating System Pragmatics (Spring 2019)<br>
</i></small>
<p>
<center>
<big><b>Phase 7 &nbsp; <i>Exec</i> and <i>Signal</i> IPC</b></big></b>
</center>

<h3>Goals</h3>
The goals of our OS in this phase are two parts.
<ol>
<li>
To create a stand-alone process using its own assigned memory space for
both code and runtime. This means the OS will need to manage RAM usages.
<li>
To cater the well famed <i>SIGNAL</i> IPC service which involves the
alteration of process runtime. The service thus allows a process to
define its own event handling routines (not those of the OS code).
The type of events are termed <i>signals</i>. One commonly known is
the SIGINT signal generated by pressing on the <i>CTRL-C</i> key (from
a STDIN channel of a process).
Signal names are listed in Linux <i>/usr/include/bits/signum.h</i>).
</ol>
<p>

<h3>Memory Mangement</h3>
<ol>
<li>
The DRAM memory will be managed by our kernel via an integer array
<i>page_user[PAGE_NUM]</i>. The un-used DRAM starts at byte location
0xe00000 (14M) where MyOS.dli ends. We will test with 20 pages, each
has PAGE_SIZE/4096 bytes in size. The array index is the page number,
and the integer in it is the PID of the process using the page.
<p>
<li>
To figure out the address of a page: take its index number, multiplied
it with page size, and add the DRAM starting address, e.g., page #3
starts at byte location 0xe00000 + 3 * 4096.
<p>
<li>
The page_user array is initialized all NONE during the bootstrap.
To allocation a page is to search this array for one that has NONE
during a process creation (in ExecSR).
<p>
<li>
As a process exits, the DRAM pages in use by that process should be
reclaimed (in both ExitSR and WaitSR</i>, if a child process can
finally be terminated.
<p>
</ol>

<h3>Exec Service</h3>
<ol>
<li>
A new <i>ExecSR</i> service will be used for a newly forked child
process to request for memory space and to run brand new code
(separation of parent's code). This is similar to an external
shell command: a child process is first forked with the shell
image, and then call an <i>EXEC</i> type of service to separate
the program code to a new program, along with a new runtime stack.
<p>
<li>
The new syscall is <i><b>void ExecCall(int code_addr, int device)</b></i>
where <i>code_addr</i> is tested with the address of <i>void Aout(int device)</i>
(which is the same as in the previous phase), and the <i>device</i>
comes from the parent's device.
<p>
<li>
In order to create a process with arguments such as 'device,' the
arguments must be asserted above the new trapframe in the stack.
<p>
<li>
In <i>ExecSR()</i> two DRAM pages are first to be allocated in order
to create a code page and a stack page. By copying in the program code,
the code page is built easily. For the stack page it has not only an
initial trapframe, but also an argument atop of the trapframe for the
process to get when run. The argument is placed on the top of the stack
page, <b>followed by a dummy return address</b> (just 0 is fine).
And, beneath them, the new trapframe is built.
<p>
<li>
The PCB of the process being served is only altered in the trapframe
location (to the new one in the stack page). The <i>eip</i> of the new
trapframe should be set to the starting address of the code page (which
has new instructions copied there to run).
<p>
<li>
The Exec() call has an integer as the function return. This return
is used for the newly forked child process to receive and check.
If the return is -1, the Exec() call failed. Otherwise, a succesful
Exec service does not return nevertheless. (Why?)
<p>
<li>
The WaitISR() and ExitISR() must reclaim DRAM pages as a child process
finally ends.
</ol>

<h3>Signal IPC</h3>
<ol>
<li>
The syscall <i><b>void SignalCall(int sig_num, int handler_addr)</b></i>
informs the OS (in the future) to redirect the process' runtime to the
handler at the signal event, and resume the original runtime. (Although
our OS doesn't have this, the default OS action for handling a ctrl-C
event is to terminate the current foreground-running process.)
<p>
<li>
A given <i>void Ouch(int device)</i> code will be used as the user signal
handler for signal <i>SIGINT</i>. The <i>UserProc</i> code registers this
handler by a <i>SignalCall()</i> call (before the infinite loop begins).
Ouch() will execute "automagically" whenever the <i>CTRL-C</i> key is
pressed at the terminal the UserProc uses.
</ol>
<p>

<h3>Runtime Stack Alteration</h3>
<ol>
<li>
In order to redirect the runtime flow of a process, its runtime stack
needs to be altered. Once a signal event occurs, the instruction
continuation address is in the <i>eip</i> register of the trapframe.
This can be eplaced by the address of a signal handler such as <i>Ouch</i>,
while the original <i>eip</i> will be inserted before the trapframe,
and as the handler ends, its last instruction <i>ret</i> will <i>pop</i>
it back to <i>eip</i> to continue with the instruction execution. Thus,
the trapframe in the runtime stack needs to be lowered to accommodate
the insertion of the original <i>eip</i>.
<p>
<li>
However, the above organization will have the signal handler run with
other register values from the process trapframe (not meant for the
handler). This may cause fatal errors. Hence, <i>pushal</i> and
<i>popal</i> instructions are needed before and after the handler.
<p>
<li>
For the above reason, we use <i>void Wrapper(int handler_address, int arg)</i>
to <i>wrap</i> around the actual handler: first <i>pushal</i>, then call the
handler, and afterward, <i>popal</i> and return (back to UserProc).
<p>
<li>
To <i>implant</i> 'handler_addr' and 'arg' as arguments to Wrapper(),
      The runtime stack of the process UserProc is altered to:<pre>
      ... UserProc runtime stuff stacked (unchanged)
      --> 'arg'
      --> 'handler_addr'
      --> eip of the original UserProc trapframe, to resume it
      ... the original trapframe except eip = Wrapper

      When the above trapframe is popped, Wrapper code starts:
      --> push ebp (ebp of the original TF of UserProc)
      ... pushal
      --> calls 'handler_addr' with 'arg'
      (push eip to resume Wrapper)
      --> Handler code: push ebp of Wrapper
      ... stuff got stacked while running Handler

      Finally:
         When Handler ends: mov ebp, esp; pop ebp; ret (pop eip, back to Wrapper)
         Wrapper resumes: popal (things of original TF are back)
         Wrapper ends: mov ebp, esp; pop ebp; ret (pop eip, back to UserProc)</pre>
</ol>

<h3>Deliverables</h3>
<ol>
<li>
Correct errors in the grading results once they get posted or you will
get points deducted again.
<p>
<li>
As before, submit only source-code files (*.c, *.h, and k-entry.S) to your
team dropbox on host Voyager, in the designated phase folder.
<p>
<li>
All other rules declared from previous phases regarding not to mess
up submission directories and not to conduct plagiarism also apply.
</ol>

<h3>Review Questions</h3>
<ol>
<li>
ExecSR allocates a DRAM page for code and another for runtime stack.
Why isn't there a data page?
<p>
<li>
What can constitute the phenomenon of 'memory leak' in our OS code?
<p>
<li>
How can a process withdraw a previously signal handling request?
Corollarily, can a default signal handler be recovered after a
user process withdraw a previous reqeust?
<p>
<li>
How can signal <i>SIGCHLD</i> be used to construct for background
running processes, e.g., when shell receives commands with an ampersand
symbol at the end?
<p>
<li>
What are these signal-related service calls: <i>pause()</i>, <i>raise()</i>,
<i>kill()</i>, <i>signal()</i>, <i>atexit()</i>, <i>wait()</i>, and
<i>wait3()</i>?
</ol>
